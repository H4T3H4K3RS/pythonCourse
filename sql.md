# Задание 1

1. Вывести список сотрудников, получающих зарплату больше, чем зарплата их непосредственного руководителя
```sql
SELECT e.ID, e.NAME, e.SALARY
FROM Employee e
WHERE e.SALARY > (SELECT s.SALARY FROM Employee s WHERE s.ID = e.CHIEF_ID);
```
Этот запрос выбирает идентификатор, имя и зарплату сотрудника из таблицы Employee, если зарплата сотрудника больше, чем зарплата его непосредственного руководителя. Это достигается путем использования подзапроса для выбора зарплаты руководителя с тем же ID, что и CHIEF_ID сотрудника, и сравнения ее с зарплатой сотрудника.

2. Вывести список сотрудников, получающих максимальную зарплату в своем отделе
```sql
SELECT e.ID, e.NAME, e.SALARY
FROM Employee e
WHERE e.SALARY = (
  SELECT MAX(SALARY)
  FROM Employee
  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID
);
```
Этот запрос выбирает идентификатор, имя и зарплату сотрудника из таблицы Employee, если зарплата сотрудника равна максимальной зарплате в его отделе. Это достигается путем использования подзапроса для поиска максимальной зарплаты в том же отделе, что и сотрудник, а затем сравнения ее с зарплатой сотрудника.

3. Вывести список идентификаторов отделов, в которых работает не более 3 сотрудников
```sql
SELECT DEPARTMENT_ID
FROM Employee
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) <= 3;
```
Этот запрос выбирает из таблицы Employee ID отдела, в котором число сотрудников отдела меньше или равно 3. Это достигается путем группировки данных по ID отдела, а затем фильтрации групп с количеством сотрудников меньше или равно 3 с помощью условия HAVING.

4. Выведите список таких сотрудников, у которых нет назначенного менеджера, работающего в том же отделе.
```sql
SELECT e.ID, e.NAME, e.DEPARTMENT_ID
FROM Employee e
WHERE e.CHIEF_ID IS NULL
  OR e.CHIEF_ID NOT IN (SELECT m.ID FROM Employee m WHERE m.DEPARTMENT_ID = e.DEPARTMENT_ID);
```
Этот запрос выбирает ID сотрудника, имя и ID отдела из таблицы Employee, если у сотрудника либо нет руководителя (т.е. его CHIEF_ID равен NULL), либо его руководитель не работает в том же отделе, что и он. Это достигается с помощью комбинации логических операторов и подзапросов для соответствующей фильтрации данных.

5. Найти список идентификаторов отделов с максимальной суммарной зарплатой сотрудников
```sql
SELECT e.DEPARTMENT_ID
FROM Employee e
GROUP BY e.DEPARTMENT_ID
HAVING SUM(e.SALARY) = (
  SELECT MAX(total_salary)
  FROM (
    SELECT DEPARTMENT_ID, SUM(SALARY) as total_salary
    FROM Employee
    GROUP BY DEPARTMENT_ID
  )
);
```
Этот запрос выбирает идентификатор отдела из таблицы Employee, где общая зарплата сотрудников отдела равна максимальной общей зарплате по всем отделам. Это достигается путем группировки данных по ID отдела, а затем фильтрации групп с общей зарплатой, равной максимальной общей зарплате по всем отделам, которая находится с помощью подзапроса, вычисляющего общую зарплату для каждого отдела и выбирающего максимальное значение.

# Задание 2

1. Актуальные записи 

SUBS:

| SUBS_ID | NAME  | CITY_ID | BEG_DT   | END_DT   |
| ------- | ----- | ------- | -------- | -------- |
| 2       | Петя | 5       | 2010-01-01 | 9999-01-01 |

CITY:

| CITY_ID | NAME    | BEG_DT   | END_DT   |
| ------- | ------- | -------- | -------- |
| 4       | Омск    | 1990-01-01 | 9999-01-01 |
| 5       | Томск   | 1900-01-01 | 9999-01-01 |

2. Чтобы объединить таблицы SUBS и CITY, мы можем использовать простой оператор JOIN на столбце CITY_ID. Вот SQL-запрос:

```sql
SELECT s.SUBS_ID, s.NAME, c.NAME AS CITY_NAME, s.BEG_DT, s.END_DT
FROM SUBS s
JOIN CITY c ON s.CITY_ID = c.CITY_ID
```

Этот запрос вернет таблицу с идентификатором абонента, именем, названием города, датой начала и датой окончания.

Вот результирующая таблица после объединения таблиц SUBS и CITY:

| SUBS_ID	| NAME    | CITY_NAME | BEG_DT      | END_DT     |
| ------- | ------- | --------- | ----------- | ---------- |
| 2      	| Vasya 	| Omsk    	| 1900-01-01	| 2001-01-01 |
| 2	      | Petya	  | Omsk	    | 2001-01-01	| 2010-01-01 |
| 2	      | Petya	  | Tomsk	    | 2010-01-01	| 9999-01-01 |

# Задание 3

Исходя из постановки задачи, мы можем определить следующие сущности:

`Polygon` - Представляет цветной многоугольник на оси 2D.

`Vertex` - Представляет собой вершины многоугольников

Таблица многоугольников может быть такой:

#### Polygon

`Polygon_ID` (primary key) - уникальный идентификатор многоугольника

`Color_Hex_Code` - шестнадцатеричный код цвета, присвоенного многоугольнику.

А таблица вершин может быть такой:

#### Vertex

`Vertex_ID` (primary key) - уникальный идентификатор для вершины

`X_coordinate` - x-координата вершины

`Y_координата` - y-координата вершины

`Polygon_ID` (внешний ключ) - идентификатор полигона, к которому принадлежит вершина.

`Sequence` - целое число, представляющее порядок соединения вершин


С помощью этих таблиц мы можем подсчитать количество вершин, принадлежащих многоугольнику, используя запрос, который группирует вершины по многоугольнику и подсчитывает количество записей.

Отношения для этих таблиц выглядят следующим образом:

Многоугольник

`Polygon(Polygon_ID, Color_Hex_Code)`

Вершина

`Vertex(Vertex_ID, X_coordinate, Y_coordinate, Polygon_ID)`

Оба отношения находятся в `ЗНФ`, поскольку содержат только один ключ-кандидат.

Вот пример того, как мы можем представить многоугольники, расположенные на изображении, с помощью модифицированной модели данных, которую мы обсуждали ранее. Для простоты мы будем считать, что многоугольники расположены в двухмерном пространстве с координатами от 0 до 10.

Таблица многоугольников:
| Polygon_ID	| Color_Hex_Code |
| ----------- | -------------- |
| 1           | #00FF00.       |
| 2	          | #FFFF00        |
| 3	          | #FF0000        |

Таблица вершин:
| Vertex_ID	 | X_coordinate|	Y_coordinate	|Polygon_ID	|Sequence
| ----------- | -------------- | ----------- | -------------- | ------- |
| 1	| 2	| 5	| 1| 	1| 
| 2	| 4	| 5	| 1| 	2| 
| 3	| 3	| 7	| 1| 	3| 
| 4	| 1.8| 	2.7	| 2| 	1| 
| 5	| 3	| 1	| 2	| 2| 
| 6	| 5	| 2.7| 	2	| 3| 
| 7	| 7.2| 	2.7	| 2	| 4| 
| 8	| 8	| 5	| 2	| 5| 
| 9	| 5	| 7.5| 	3| 	1| 
| 10	| 6	| 9| 	3| 	2| 
| 11	| 7	| 7.5| 	3| 	3| 
| 12	| 9	| 7.5| 	3	| 4| 
| 13	| 7	| 5| 	3| 	5| 
